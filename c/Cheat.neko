# Originally from dldb.info/blog/506
# Modified by me

# Save cheat config function
  class Do_Not_Edit_This_File
    def checking(type)
      case type
        when "move"; @move
        when "dash"; @dash
        when "bgm"; @bgm
        when "bgs"; @bgs
        when "me"; @me
        when "se"; @se
        when "txt"; @text
        when "exp"; @neko_exp
        when "encount"; @encount
        when "encount2"; @encount2
        when "cheat"; @cheat
        when "debug" ; @debug 
        when "type"; @type
        when "battle"; @battle
        when "nobattle"; @nobattle
      end
    end
    def changing(type,text)
      case type
        when "move"; @move = text
        when "dash"; @dash = text
        when "bgm"; @bgm = text
        when "bgs"; @bgs = text
        when "me"; @me = text
        when "se"; @se = text
        when "txt"; @text = text
        when "exp"; @neko_exp = text
        when "encount"; @encount = text
        when "encount2"; @encount2 = text
        when "debug" ; @debug = text
        when "battle"; @battle = text
        when "nobattle"; @nobattle = text
        when "cheat"; @cheat = text
      end
    end
    def opening(type)
      if checking(type) == nil
        changing(type,false) 
        return false
      else
        return checking(type)
      end
    end
    
    def cheat_save
      save_data($setting,"Save.neko")
    end
  end
  
# Load cheat config function
  class Game_Player < Game_Character  
    def checking(type)
      case type
        when "move"; @move
        when "dash"; @dash
        when "bgm"; @bgm
        when "bgs"; @bgs
        when "me"; @me
        when "se"; @se
        when "txt"; @text
        when "exp"; @neko_exp
        when "battle"; @battle
        when "nobattle"; @nobattle
        when "encount"; @encount
        when "encount2"; @encount2
        when "cheat"; @cheat
        when "debug" ; @debug 
        when "type"; @type
      end
    end
    
    def changing(type,text)
      case type
        when "move"; @move = text
        when "dash"; @dash = text
        when "bgm"; @bgm = text
        when "bgs"; @bgs = text
        when "me"; @me = text
        when "se"; @se = text
        when "txt"; @text = text
        when "exp"; @neko_exp = text
        when "battle"; @battle = text
        when "nobattle"; @nobattle = text
        when "encount"; @encount = text
        when "encount2"; @encount2 = text
        when "debug" ; @debug = text
        when "cheat"; @cheat = text
      end
    end
    
    def opening(type)
      if checking(type) == nil
        changing(type,false)
        return $setting.opening(type)
      else
        return checking(type) if checking(type)
        return $setting.opening(type)
      end
    end
    
    def cheat_save
    end
  end

# Key event handler
  class Scene_Map
    alias update_scene_dime update_scene if !$setting
    def update_scene
      update_scene_dime
      update_opening unless scene_changing?
    end
	
    def update_opening
      opening if Input.trigger?(:F8) && !$game_player.moving?
      SceneManager.call(Scene_Debug) if Input.press?(:F9) && $game_player.opening("debug") == 1 && !$game_player.moving? && !$TEST
      @opened = false
    end
    
    def opening
      Sound.play_ok
      SceneManager.call(Scene_Cheat)
      Window_CheatCommand::init_command_position
    end
  end

# Create cheat menu window
  class Window_CheatCommand < Window_Command
    def make_command_list
      add_command(NEKO::Items,   :getItems)
      add_command(NEKO::Weapons,   :getWeapons)
      add_command(NEKO::Armors,   :getArmors)
      add_command(NEKO::Parameters,   :parameters_edit)
      if FileTest.exist?("tele/pos_1.neko" || "tele/pos_2.neko" || "tele/pos_3.neko" || "tele/pos_4.neko" || "tele/pos_5.neko" || "tele/pos_6.neko" || "tele/pos_7.neko" || "tele/pos_8.neko")
        add_command(NEKO::Tel,   :tel)
      end
      add_command(NEKO::Setting1,   :setting_edit1)
      add_command(NEKO::Setting2,   :setting_edit2)
      add_command(NEKO::Fullsize, :screen_full)
      add_command(NEKO::Size, :screen_change)
    end
  end

# Handle for cheat menu and get items function
  class Scene_Cheat < Scene_MenuBase
    def start
      super
      create_command_window
    end

    def create_command_window
      @cheat_window = Window_CheatCommand.new
      @cheat_window.set_handler(:getItems, method(:cheat_items))
      @cheat_window.set_handler(:getWeapons, method(:cheat_weapons))
      @cheat_window.set_handler(:getArmors, method(:cheat_armors))
      @cheat_window.set_handler(:tel,      method(:neko_tel))
      @cheat_window.set_handler(:parameters_edit,      method(:edit_parameters))
      @cheat_window.set_handler(:setting_edit1,      method(:setting1))
      @cheat_window.set_handler(:setting_edit2,      method(:setting2))
      @cheat_window.set_handler(:screen_full, method(:screen_full))
      @cheat_window.set_handler(:screen_change, method(:screen_change))
      @cheat_window.set_handler(:cancel,    method(:return_scene))
    end
    def cheat_getItem(type)
        @cheat_window.close
        @cheat_item_window = Window_GetItem.new(0,0,320,type)
        @cheat_item_window.set_handler(:ok,     method(:on_buy_ok))
        @cheat_item_window.set_handler(:cancel, method(:cheat_buy_cancel))
        @cheat_item_window.show.activate
        @number_window = Window_ShopNumber.new(0, 304, 120)
        @number_window.hide
        @number_window.set_handler(:ok,     method(:on_number_ok))
        @number_window.set_handler(:cancel, method(:on_number_cancel))
      end
  
    def cheat_items
      cheat_getItem(0)
    end
 
    def cheat_weapons
      cheat_getItem(1)
    end
 
    def cheat_armors
      cheat_getItem(2)
    end

    def on_buy_ok
      @cheat_item = @cheat_item_window.item
      @cheat_item_window.hide
      @number_window.set(@cheat_item, max_buy, buying_price, "G")
      @number_window.show.activate
    end
    def cheat_buy_cancel
      @cheat_item_window.close
      return_scene
    end
    def on_number_ok
      do_buy(@number_window.number)
      @number_window.hide
      @cheat_item_window.show.activate
    end
    def on_number_cancel
      @number_window.hide
      @cheat_item_window.show.activate
    end
    def do_buy(number)
      $game_party.gain_item(@cheat_item, number)
    end
    def max_buy
      max = $game_party.max_item_number(@cheat_item) - $game_party.item_number(@cheat_item)
      buying_price == 0 ? max : [max, money / buying_price].min
    end
    def buying_price
      @cheat_item_window.price(@cheat_item)
    end
  end

# Create get items menu
  class Window_GetItem < Window_Selectable
    def initialize(x, y, height,type)
      super(x, y, window_width, height)
      @shop_goods = []
      if type == 0
        @shop_goods += $data_items
      end
      if type == 1
        @shop_goods += $data_weapons
      end
      if type == 2
        @shop_goods += $data_armors
      end
      @money = 0
      refresh
      select(0)
    end
    def window_width
      return 304
    end
    def item_max
      @cheat_data ? @cheat_data.size : 1
    end
    def item
      @cheat_data[index]
    end
    def money=(money)
      @money = money
      refresh
    end
    def current_item_enabled?
      enable?(@cheat_data[index])
    end
    def price(item)
      @cheat_price[item]
    end
    def enable?(item)
      item && !$game_party.item_max?(item)
    end
    def refresh
      make_item_list
      create_contents
      draw_all_items
    end
    def make_item_list
      @cheat_data = []
      @cheat_price = {}
      @shop_goods.each do |good|
        if good && good.name != ""
          @cheat_data.push(good)
          @cheat_price[good] = 0
        end
      end
    end
    def draw_item(index)
      item = @cheat_data[index]
      rect = item_rect(index)
      draw_item_name(item, rect.x, rect.y, enable?(item))
      rect.width -= 4
      draw_text(rect, price(item), 2)
    end
  end

  class Scene_Cheat < Scene_MenuBase
    def neko_shop_start(item)
      goods = []
      for i in item[0]...item[1] + 1
        goods.push([0,i,1,0]) if $data_items[i].name != ""        
      end
      return_scene
      SceneManager.call(Scene_Shop)
      SceneManager.scene.prepare(goods, false)
    end
  end

# Teleport function
  class Window_CheatTel < Window_CheatCommand
    def make_command_list
      if FileTest.exist?("tele/pos_1.neko")
	add_command(NEKO::SavePos + "1", :save_pos_1, true, "tele/pos_1.neko")
        add_command(NEKO::LoadPos + "1", :tele_pos_1, true, File.read("tele/pos_1.neko").split)
      end
      if FileTest.exist?("tele/pos_2.neko")
	add_command(NEKO::SavePos + "2", :save_pos_2, true, "tele/pos_2.neko")
        add_command(NEKO::LoadPos + "2", :tele_pos_2, true, File.read("tele/pos_2.neko").split)
      end
      if FileTest.exist?("tele/pos_3.neko")
	add_command(NEKO::SavePos + "3", :save_pos_3, true, "tele/pos_3.neko")
        add_command(NEKO::LoadPos + "3", :tele_pos_3, true, File.read("tele/pos_3.neko").split)
      end
      if FileTest.exist?("tele/pos_4.neko")
	add_command(NEKO::SavePos + "4", :save_pos_4, true, "tele/pos_4.neko")
        add_command(NEKO::LoadPos + "4", :tele_pos_4, true, File.read("tele/pos_4.neko").split)
      end
      if FileTest.exist?("tele/pos_5.neko")
        add_command(NEKO::SavePos + "5", :save_pos_5, true, "tele/pos_5.neko")
        add_command(NEKO::LoadPos + "5", :tele_pos_5, true, File.read("tele/pos_5.neko").split)
      end
      if FileTest.exist?("tele/pos_6.neko")
	add_command(NEKO::SavePos + "6", :save_pos_6, true, "tele/pos_6.neko")
        add_command(NEKO::LoadPos + "6", :tele_pos_6, true, File.read("tele/pos_6.neko").split)
      end
      if FileTest.exist?("tele/pos_7.neko")
	add_command(NEKO::SavePos + "7", :save_pos_7, true, "tele/pos_7.neko")
        add_command(NEKO::LoadPos + "7", :tele_pos_7, true, File.read("tele/pos_7.neko").split)
      end
      if FileTest.exist?("tele/pos_8.neko")
	add_command(NEKO::SavePos + "8", :save_pos_8, true, "tele/pos_8.neko")
        add_command(NEKO::LoadPos + "8", :tele_pos_8, true, File.read("tele/pos_8.neko").split)
      end
    end
  end

# Handle for teleport function
  class Scene_Cheat < Scene_MenuBase
    def neko_tel()
      if @neko_teleport
      else
        @neko_teleport = Window_CheatTel.new
        @neko_teleport.set_handler(:save_pos_1, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_1, method(:tel))
        @neko_teleport.set_handler(:save_pos_2, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_2, method(:tel))
        @neko_teleport.set_handler(:save_pos_3, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_3, method(:tel))
        @neko_teleport.set_handler(:save_pos_4, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_4, method(:tel))
        @neko_teleport.set_handler(:save_pos_5, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_5, method(:tel))
        @neko_teleport.set_handler(:save_pos_6, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_6, method(:tel))
        @neko_teleport.set_handler(:save_pos_7, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_7, method(:tel))
        @neko_teleport.set_handler(:save_pos_8, method(:save_pos))
        @neko_teleport.set_handler(:tele_pos_8, method(:tel))
        @neko_teleport.set_handler(:cancel, method(:hide_tel))
      end
      show_sub_window(@neko_teleport)
    end
	
	def hide_tel
	  hide_sub_window(@neko_teleport)
	end
	
	def save_pos
	  pos_file = @neko_teleport.current_ext
	  File.open(pos_file, "w") { |f| f.write $game_map.map_id.to_s + ", " + $game_player.x.to_s + ", " + $game_player.y.to_s}
	  return_scene
	end

    def tel
      pos_1_map = @neko_teleport.current_ext[0]
	  pos_1_x = @neko_teleport.current_ext[1]
	  pos_1_y = @neko_teleport.current_ext[2]
      $game_player.reserve_transfer(pos_1_map.to_i, pos_1_x.to_i, pos_1_y.to_i, 0)
      SceneManager.goto(Scene_Map)
    end
  end

# Create parameters menu
  class Window_CheatParameters < Window_CheatCommand
    def make_command_list
      add_command(NEKO::Gold,   :gold_edit, true)
      add_command(NEKO::Lv,   :lv_edit, true)
      add_command(NEKO::Edit_Parameter + "MHP",   :mhp_edit, true)
      add_command(NEKO::Edit_Parameter + "MMP",   :mmp_edit, true)
      add_command(NEKO::Edit_Parameter + "ATK",   :atk_edit, true)
      add_command(NEKO::Edit_Parameter + "DEF",   :def_edit, true)
      add_command(NEKO::Edit_Parameter + "MAT",   :mat_edit, true)
      add_command(NEKO::Edit_Parameter + "MDF",   :mdf_edit, true)
      add_command(NEKO::Edit_Parameter + "AGI",   :agi_edit, true)
      add_command(NEKO::Edit_Parameter + "LUK",   :luk_edit, true)
    end
  end

# Handle for parameters menu
  class Scene_Cheat < Scene_MenuBase
    def edit_parameters
      if @edit_parameters
      else
        @edit_parameters = Window_CheatParameters.new
        @edit_parameters.set_handler(:gold_edit,      method(:neko_gold))
        @edit_parameters.set_handler(:lv_edit,      method(:neko_lv))
        @edit_parameters.set_handler(:mhp_edit,      method(:neko_mhp))
        @edit_parameters.set_handler(:mmp_edit,      method(:neko_mmp))
        @edit_parameters.set_handler(:atk_edit,      method(:neko_atk))
        @edit_parameters.set_handler(:def_edit,      method(:neko_def))
        @edit_parameters.set_handler(:mat_edit,      method(:neko_mat))
        @edit_parameters.set_handler(:mdf_edit,      method(:neko_mdf))
        @edit_parameters.set_handler(:agi_edit,      method(:neko_agi))
        @edit_parameters.set_handler(:luk_edit,      method(:neko_luk))
        @edit_parameters.set_handler(:cancel, method(:hide_parameters))
      end
      show_sub_window(@edit_parameters)
    end
    def hide_parameters
      hide_sub_window(@edit_parameters)
    end
  end

# Create MHP menu
  class Window_CheatMHP < Window_CheatCommand
    def make_command_list
      add_command("+1 MHP", :add_mhp, true, 1)
      add_command("+5 MHP", :add_mhp, true, 5)
      add_command("+10 MHP", :add_mhp, true, 10)
      add_command("+50 MHP", :add_mhp, true, 50)
      add_command("+100 MHP", :add_mhp, true, 100)
      add_command("+500 MHP", :add_mhp, true, 500)
      add_command("+1000 MHP", :add_mhp, true, 1000)
	  add_command("+5000 MHP", :add_mhp, true, 5000)
	  add_command("+10000 MHP", :add_mhp, true, 10000)
	  add_command("+999999 MHP", :add_mhp, true, 999999)
      add_command("-1 MHP", :add_mhp, true, -1)
      add_command("-5 MHP", :add_mhp, true, -5)
      add_command("-10 MHP", :add_mhp, true, -10)
      add_command("-50 MHP", :add_mhp, true, -50)
      add_command("-100 MHP", :add_mhp, true, -100)
      add_command("-500 MHP", :add_mhp, true, -500)
      add_command("-1000 MHP", :add_mhp, true, -1000)
	  add_command("-5000 MHP", :add_mhp, true, -5000)
	  add_command("-10000 MHP", :add_mhp, true, -10000)
	  add_command("-999999 MHP", :add_mhp, true, -999999)
    end
  end

# Handle for MHP edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_mhp()
      if @neko_mhp
      else
        @neko_mhp = Window_CheatMHP.new
        @neko_mhp.set_handler(:add_mhp, method(:add_mhp))
        @neko_mhp.set_handler(:cancel, method(:hide_mhp))
      end
      @now_menu = "mhp"
      show_parameter_window
    end
    def hide_mhp
      hide_parameter_window
    end
    def add_mhp
      mhp = @neko_mhp.current_ext
      if @add_mhp
      else
        @add_mhp = Edit_Interpreter.new()
      end
      @add_mhp.mhp_change(mhp)
      @add_mhp.text(NEKO::Added + mhp.to_s + " MHP" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create MMP menu
  class Window_CheatMMP < Window_CheatCommand
    def make_command_list
      add_command("+1 MMP", :add_mmp, true, 1)
      add_command("+5 MMP", :add_mmp, true, 5)
      add_command("+10 MMP", :add_mmp, true, 10)
      add_command("+50 MMP", :add_mmp, true, 50)
      add_command("+100 MMP", :add_mmp, true, 100)
      add_command("+500 MMP", :add_mmp, true, 500)
      add_command("+1000 MMP", :add_mmp, true, 1000)
      add_command("+5000 MMP", :add_mmp, true, 5000)
      add_command("+10000 MMP", :add_mmp, true, 10000)
      add_command("+999999 MMP", :add_mmp, true, 999999)
      add_command("-1 MMP", :add_mmp, true, -1)
      add_command("-5 MMP", :add_mmp, true, -5)
      add_command("-10 MMP", :add_mmp, true, -10)
      add_command("-50 MMP", :add_mmp, true, -50)
      add_command("-100 MMP", :add_mmp, true, -100)
      add_command("-500 MMP", :add_mmp, true, -500)
      add_command("-1000 MMP", :add_mmp, true, -1000)
      add_command("-5000 MMP", :add_mmp, true, -5000)
      add_command("-10000 MMP", :add_mmp, true, -10000)
      add_command("-999999 MMP", :add_mmp, true, -999999)
    end
  end

# Handle for MMP edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_mmp()
      if @neko_mmp
      else
        @neko_mmp = Window_CheatMMP.new
        @neko_mmp.set_handler(:add_mmp, method(:add_mmp))
        @neko_mmp.set_handler(:cancel, method(:hide_mmp))
      end
      @now_menu = "mmp"
      show_parameter_window
    end
    def hide_mmp
      hide_parameter_window
    end
    def add_mmp
      mmp = @neko_mmp.current_ext
      if @add_mmp
      else
        @add_mmp = Edit_Interpreter.new()
      end
      @add_mmp.mmp_change(mmp)
      @add_mmp.text(NEKO::Added + mmp.to_s + " MMP" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create ATK menu
  class Window_CheatATK < Window_CheatCommand
    def make_command_list
      add_command("+1 ATK", :add_atk, true, 1)
      add_command("+5 ATK", :add_atk, true, 5)
      add_command("+10 ATK", :add_atk, true, 10)
      add_command("+50 ATK", :add_atk, true, 50)
      add_command("+100 ATK", :add_atk, true, 100)
      add_command("+500 ATK", :add_atk, true, 500)
      add_command("+1000 ATK", :add_atk, true, 1000)
      add_command("+5000 ATK", :add_atk, true, 5000)
      add_command("+10000 ATK", :add_atk, true, 10000)
      add_command("+999999 ATK", :add_atk, true, 999999)
      add_command("-1 ATK", :add_atk, true, -1)
      add_command("-5 ATK", :add_atk, true, -5)
      add_command("-10 ATK", :add_atk, true, -10)
      add_command("-50 ATK", :add_atk, true, -50)
      add_command("-100 ATK", :add_atk, true, -100)
      add_command("-500 ATK", :add_atk, true, -500)
      add_command("-1000 ATK", :add_atk, true, -1000)
      add_command("-5000 ATK", :add_atk, true, -5000)
      add_command("-10000 ATK", :add_atk, true, -10000)
      add_command("-999999 ATK", :add_atk, true, -999999)
    end
  end
  
# Handle for ATK edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_atk()
      if @neko_atk
      else
        @neko_atk = Window_CheatATK.new
        @neko_atk.set_handler(:add_atk, method(:add_atk))
        @neko_atk.set_handler(:cancel, method(:hide_atk))
      end
      @now_menu = "atk"
      show_parameter_window
    end
    def hide_atk
      hide_parameter_window
    end
    def add_atk
      atk = @neko_atk.current_ext
      if @add_atk
      else
        @add_atk = Edit_Interpreter.new()
      end
      @add_atk.atk_change(atk)
      @add_atk.text(NEKO::Added + atk.to_s + " ATK" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create DEF menu
  class Window_CheatDEF < Window_CheatCommand
    def make_command_list
      add_command("+1 DEF", :add_def, true, 1)
      add_command("+5 DEF", :add_def, true, 5)
      add_command("+10 DEF", :add_def, true, 10)
      add_command("+50 DEF", :add_def, true, 50)
      add_command("+100 DEF", :add_def, true, 100)
      add_command("+500 DEF", :add_def, true, 500)
      add_command("+1000 DEF", :add_def, true, 1000)
      add_command("+5000 DEF", :add_def, true, 5000)
      add_command("+10000 DEF", :add_def, true, 10000)
      add_command("+999999 DEF", :add_def, true, 999999)
      add_command("-1 DEF", :add_def, true, -1)
      add_command("-5 DEF", :add_def, true, -5)
      add_command("-10 DEF", :add_def, true, -10)
      add_command("-50 DEF", :add_def, true, -50)
      add_command("-100 DEF", :add_def, true, -100)
      add_command("-500 DEF", :add_def, true, -500)
      add_command("-1000 DEF", :add_def, true, -1000)
      add_command("-5000 DEF", :add_def, true, -5000)
      add_command("-999999 DEF", :add_def, true, -999999)
    end
  end

# Handle for DEF edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_def()
      if @neko_def
      else
        @neko_def = Window_CheatDEF.new
        @neko_def.set_handler(:add_def, method(:add_def))
        @neko_def.set_handler(:cancel, method(:hide_def))
      end
      @now_menu = "def"
      show_parameter_window
    end
    def hide_def
      hide_parameter_window
    end
    def add_def
      mdef = @neko_def.current_ext
      if @add_def
      else
        @add_def = Edit_Interpreter.new()
      end
      @add_def.def_change(mdef)
      @add_def.text(NEKO::Added + mdef.to_s + " DEF" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create MAT menu
  class Window_CheatMAT < Window_CheatCommand
    def make_command_list
      add_command("+1 MAT", :add_mat, true, 1)
      add_command("+5 MAT", :add_mat, true, 5)
      add_command("+10 MAT", :add_mat, true, 10)
      add_command("+50 MAT", :add_mat, true, 50)
      add_command("+100 MAT", :add_mat, true, 100)
      add_command("+500 MAT", :add_mat, true, 500)
      add_command("+1000 MAT", :add_mat, true, 1000)
      add_command("+5000 MAT", :add_mat, true, 5000)
      add_command("+10000 MAT", :add_mat, true, 10000)
      add_command("+999999 MAT", :add_mat, true, 999999)
      add_command("-1 MAT", :add_mat, true, -1)
      add_command("-5 MAT", :add_mat, true, -5)
      add_command("-10 MAT", :add_mat, true, -10)
      add_command("-50 MAT", :add_mat, true, -50)
      add_command("-100 MAT", :add_mat, true, -100)
      add_command("-500 MAT", :add_mat, true, -500)
      add_command("-1000 MAT", :add_mat, true, -1000)
      add_command("-5000 MAT", :add_mat, true, -5000)
      add_command("-10000 MAT", :add_mat, true, -10000)
      add_command("-999999 MAT", :add_mat, true, -999999)
    end
  end

# Handle for MAT edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_mat()
      if @neko_mat
      else
        @neko_mat = Window_CheatMAT.new
        @neko_mat.set_handler(:add_mat, method(:add_mat))
        @neko_mat.set_handler(:cancel, method(:hide_mat))
      end
      @now_menu = "mat"
      show_parameter_window
    end
    def hide_mat
      hide_parameter_window
    end
    def add_mat
      mat = @neko_mat.current_ext
      if @add_mat
      else
        @add_mat = Edit_Interpreter.new()
      end
      @add_mat.mat_change(mat)
      @add_mat.text(NEKO::Added + mat.to_s + " MAT" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create MDF menu
  class Window_CheatMDF < Window_CheatCommand
    def make_command_list
      add_command("+1 MDF", :add_mdf, true, 1)
      add_command("+5 MDF", :add_mdf, true, 5)
      add_command("+10 MDF", :add_mdf, true, 10)
      add_command("+50 MDF", :add_mdf, true, 50)
      add_command("+100 MDF", :add_mdf, true, 100)
      add_command("+500 MDF", :add_mdf, true, 500)
      add_command("+1000 MDF", :add_mdf, true, 1000)
      add_command("+5000 MDF", :add_mdf, true, 5000)
      add_command("+10000 MDF", :add_mdf, true, 10000)
      add_command("+999999 MDF", :add_mdf, true, 999999)
      add_command("-1 MDF", :add_mdf, true, -1)
      add_command("-5 MDF", :add_mdf, true, -5)
      add_command("-10 MDF", :add_mdf, true, -10)
      add_command("-50 MDF", :add_mdf, true, -50)
      add_command("-100 MDF", :add_mdf, true, -100)
      add_command("-500 MDF", :add_mdf, true, -500)
      add_command("-1000 MDF", :add_mdf, true, -1000)
      add_command("-5000 MDF", :add_mdf, true, -5000)
      add_command("-10000 MDF", :add_mdf, true, -10000)
      add_command("-999999 MDF", :add_mdf, true, -999999)
    end
  end

# Handle for MDF edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_mdf()
      if @neko_mdf
      else
        @neko_mdf = Window_CheatMDF.new
        @neko_mdf.set_handler(:add_mdf, method(:add_mdf))
        @neko_mdf.set_handler(:cancel, method(:hide_mdf))
      end
      @now_menu = "mdf"
      show_parameter_window
    end
    def hide_mdf
      hide_parameter_window
    end
    def add_mdf
      mdf = @neko_mdf.current_ext
      if @add_mdf
      else
        @add_mdf = Edit_Interpreter.new()
      end
      @add_mdf.mdf_change(mdf)
      @add_mdf.text(NEKO::Added + mdf.to_s + " MDF" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create AGI menu
  class Window_CheatAGI < Window_CheatCommand
    def make_command_list
      add_command("+1 AGI", :add_agi, true, 1)
      add_command("+5 AGI", :add_agi, true, 5)
      add_command("+10 AGI", :add_agi, true, 10)
      add_command("+50 AGI", :add_agi, true, 50)
      add_command("+100 AGI", :add_agi, true, 100)
      add_command("+500 AGI", :add_agi, true, 500)
      add_command("+1000 AGI", :add_agi, true, 1000)
      add_command("+5000 AGI", :add_agi, true, 5000)
      add_command("+10000 AGI", :add_agi, true, 10000)
      add_command("+999999 AGI", :add_agi, true, 999999)
      add_command("-1 AGI", :add_agi, true, -1)
      add_command("-5 AGI", :add_agi, true, -5)
      add_command("-10 AGI", :add_agi, true, -10)
      add_command("-50 AGI", :add_agi, true, -50)
      add_command("-100 AGI", :add_agi, true, -100)
      add_command("-500 AGI", :add_agi, true, -500)
      add_command("-1000 AGI", :add_agi, true, -1000)
      add_command("-5000 AGI", :add_agi, true, -5000)
      add_command("-999999 AGI", :add_agi, true, -999999)
    end
  end

# Handle for AGI edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_agi()
      if @neko_agi
      else
        @neko_agi = Window_CheatAGI.new
        @neko_agi.set_handler(:add_agi, method(:add_agi))
        @neko_agi.set_handler(:cancel, method(:hide_agi))
      end
      @now_menu = "agi"
      show_parameter_window
    end
    def hide_agi
      hide_parameter_window
    end
    def add_agi
      agi = @neko_agi.current_ext
      if @add_agi
      else
        @add_agi = Edit_Interpreter.new()
      end
      @add_agi.agi_change(agi)
      @add_agi.text(NEKO::Added + agi.to_s + " AGI" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create LUK menu
  class Window_CheatLUK < Window_CheatCommand
    def make_command_list
      add_command("+1 LUK", :add_luk, true, 1)
      add_command("+5 LUK", :add_luk, true, 5)
      add_command("+10 LUK", :add_luk, true, 10)
      add_command("+50 LUK", :add_luk, true, 50)
      add_command("+100 LUK", :add_luk, true, 100)
      add_command("+500 LUK", :add_luk, true, 500)
      add_command("+1000 LUK", :add_luk, true, 1000)
      add_command("+5000 LUK", :add_luk, true, 5000)
      add_command("+999999 LUK", :add_luk, true, 999999)
      add_command("-1 LUK", :add_luk, true, -1)
      add_command("-5 LUK", :add_luk, true, -5)
      add_command("-10 LUK", :add_luk, true, -10)
      add_command("-50 LUK", :add_luk, true, -50)
      add_command("-100 LUK", :add_luk, true, -100)
      add_command("-500 LUK", :add_luk, true, -500)
      add_command("-1000 LUK", :add_luk, true, -1000)
      add_command("-5000 LUK", :add_luk, true, -5000)
      add_command("-999999 LUK", :add_luk, true, -999999)
    end
  end

# Handle for LUK edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_luk()
      if @neko_luk
      else
        @neko_luk = Window_CheatLUK.new
        @neko_luk.set_handler(:add_luk, method(:add_luk))
        @neko_luk.set_handler(:cancel, method(:hide_luk))
      end
      @now_menu = "luk"
      show_parameter_window
    end
    def hide_luk
      hide_parameter_window
    end
    def add_luk
      luk = @neko_luk.current_ext
      if @add_luk
      else
        @add_luk = Edit_Interpreter.new()
      end
      @add_luk.luk_change(luk)
      @add_luk.text(NEKO::Added + luk.to_s + " LUK" + NEKO::Added_Parameters)
      return_scene
    end
  end

# Create level menu
  class Window_CheatLv < Window_CheatCommand
    def make_command_list
      add_command("Lv  1", :edit_lv, true, 1)
      add_command("Lv 10", :edit_lv, true, 10)
      add_command("Lv 20", :edit_lv, true, 20)
      add_command("Lv 30", :edit_lv, true, 30)
      add_command("Lv 40", :edit_lv, true, 40)
      add_command("Lv 50", :edit_lv, true, 50)
      add_command("Lv 60", :edit_lv, true, 60)
      add_command("Lv 70", :edit_lv, true, 70)
      add_command("Lv 80", :edit_lv, true, 80)
      add_command("Lv 90", :edit_lv, true, 90)
      add_command("Lv 99", :edit_lv, true, 99)
      add_command("Lv 999 (if supported)", :edit_lv, true, 999)
    end
  end

# Handle for level edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_lv()
      if @neko_lv
      else
        @neko_lv = Window_CheatLv.new
        @neko_lv.set_handler(:edit_lv, method(:edit_lv))
        @neko_lv.set_handler(:cancel, method(:hide_lv))
      end
      @now_menu = "lv"
      show_parameter_window
    end
    def hide_lv
      hide_parameter_window
    end
    def edit_lv
      lv = @neko_lv.current_ext
      if @edit_lv
      else
        @edit_lv = Edit_Interpreter.new()
      end
      @edit_lv.lv_change(lv)
      @edit_lv.text(NEKO::LV_Text_1 + lv.to_s + NEKO::LV_Text_2)
      return_scene
    end
  end

# Create gold menu
  class Window_CheatGold < Window_CheatCommand
    def make_command_list
      add_command("+1000 G", :edit_gold, true, 1000)
      add_command("+5000 G", :edit_gold, true, 5000)
      add_command("+10000 G", :edit_gold, true, 10000)
      add_command("+50000 G", :edit_gold, true, 50000)
      add_command("+100000 G", :edit_gold, true, 100000)
      add_command("+500000 G", :edit_gold, true, 500000)
      add_command("+1000000 G", :edit_gold, true, 1000000)
      add_command("+5000000 G", :edit_gold, true, 5000000)
      add_command("+10000000 G", :edit_gold, true, 10000000)
      add_command("+50000000 G", :edit_gold, true, 10000000)
      add_command("+99999999 G", :edit_gold, true, 99999999)
    end
  end

# Handle for gold edit function
  class Scene_Cheat < Scene_MenuBase
    def neko_gold()
      if @neko_gold
      else
        @neko_gold = Window_CheatGold.new
        @neko_gold.set_handler(:edit_gold, method(:edit_gold))
        @neko_gold.set_handler(:cancel, method(:hide_gold))
      end
      @now_menu = "gold"
      show_parameter_window
    end
    def hide_gold
      hide_parameter_window
    end
    def edit_gold
      gold_value = @neko_gold.current_ext
      if @edit_gold
      else
        @edit_gold = Edit_Interpreter.new()
      end
      @edit_gold.gold_change(gold_value)
      @edit_gold.text(NEKO::Added + gold_value.to_s + NEKO::Gold_Text)
      return_scene
    end
  end

# Handle for parameter edit function
  class Edit_Interpreter < Game_Interpreter
    def lv_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.change_level(i, false)
      end
    end

   def mhp_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(0, i)
      end
    end

   def mmp_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(1, i)
      end
    end

   def atk_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(2, i)
      end
    end

   def def_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(3, i)
      end
    end

   def mat_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(4, i)
      end
    end

   def mdf_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(5, i)
      end
    end

   def agi_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(6, i)
      end
    end

   def luk_change(i)
      iterate_actor_var(0, 0) do |actor|
        actor.add_param(7, i)
      end
    end
	
   def gold_change(i)
     $game_party.gain_gold(i)
    end

    def text(i)
      $game_message.add(i)
    end
  end

# Handle for creating menu
  class Window_CheatCommand < Window_Command
    def self.init_command_position
      @@last_command_symbol = nil
    end
    def initialize
      super(0, 0)
    end
    def visible_line_number
      item_max
    end
    def menu_name
      return @select_cheat
    end
    def process_ok
      @@last_command_symbol = current_symbol
      super
    end
  end

# Create config menu
  class Window_CheatSetting < Window_CheatCommand
    def make_command_list
      add_command(NEKO::Move, :edit_move, true, "move")
      add_command(NEKO::Dash, :edit_dash, true, "dash")
      add_command(NEKO::Exp, :edit_exp, true, "exp")
      add_command(NEKO::Encount, :edit_encount, true, "encount")
      add_command(NEKO::Encount2, :edit_encount2, true, "encount2")
      add_command(NEKO::Text, :edit_text, true, "txt")
      add_command(NEKO::Battle, :edit_battle, true, "battle")
      add_command(NEKO::NoBattle, :edit_nobattle, true, "nobattle")
      add_command(NEKO::Debug, :edit_debug, true, "debug")
      add_command(NEKO::Bgm, :edit_bgm, true, "bgm")
      add_command(NEKO::Bgs, :edit_bgs, true, "bgs")
      add_command(NEKO::Me, :edit_me, true, "me")
      add_command(NEKO::Se, :edit_se, true, "se")
    end
  end

# Check if player use config (this session) or config all game session
  class Scene_Cheat < Scene_MenuBase
    def setting1
      @now_setting = $setting
      setting
    end
    def setting2
      @now_setting = $game_player
      setting
    end
    def close
      @now_setting = false
    end
	
# Handle for setting menu
    def setting
      @setting = Window_CheatSetting.new
      @setting.set_handler(:edit_move, method(:neko_speed))
      @setting.set_handler(:edit_dash, method(:neko_speed))
      @setting.set_handler(:edit_exp, method(:neko_exp))
      @setting.set_handler(:edit_text, method(:neko_text))
      @setting.set_handler(:edit_debug, method(:neko_debug))
      @setting.set_handler(:edit_encount, method(:neko_encount))
      @setting.set_handler(:edit_encount2, method(:neko_encount2))
      @setting.set_handler(:edit_battle, method(:neko_battle))
      @setting.set_handler(:edit_nobattle, method(:neko_battle))
      @setting.set_handler(:edit_bgm, method(:neko_sound))
      @setting.set_handler(:edit_bgs, method(:neko_sound))
      @setting.set_handler(:edit_me, method(:neko_sound))
      @setting.set_handler(:edit_se, method(:neko_sound))
      @setting.set_handler(:cancel, method(:setting_cancel))
      show_sub_window(@setting)
    end
  end

# Handle for opening and closing config
  class Window_CheatCommand_Setting < Window_CheatCommand
    alias neko_initialize initialize if !$setting
    def initialize(type,text)
      @now_setting = type
      @select_cheat = text
      neko_initialize
    end
    def close
      @now_setting = false
      @select_cheat = false
    end
  end

# Handle for movement speed menu
  class Window_CheatMove < Window_CheatCommand_Setting
    def make_command_list
      imsi = @now_setting.checking(menu_name)
      for i in 4...10
        if i == imsi
          add_command(i.to_s + NEKO::Now, :change_type, true, i)
        else
          add_command(i.to_s, :change_type, true, i)
        end
      end
      if imsi == false || imsi == nil
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      else
        add_command(NEKO::Base, :change_type, true, false)
      end
    end
  end

# Handle for battle speed menu
  class Window_CheatBattle < Window_CheatCommand_Setting
    def make_command_list
      imsi = @now_setting.checking(menu_name)
      for i in 1...11
        if i == imsi
          add_command(i.to_s + "x" + NEKO::Now, :change_type, true, i)
        else
          add_command(i.to_s + "x" , :change_type, true, i)
        end
      end
      if imsi == false || imsi == nil
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      else
        add_command(NEKO::Base, :change_type, true, false)
      end
    end
  end  

# Handle for Exp multiply menu
  class Window_Exp < Window_CheatCommand_Setting
    def make_command_list
      imsi = @now_setting.checking(menu_name)
      for i in 0...11
        if imsi == i
          add_command(i.to_s + "x" + NEKO::Now, :change_type, true, i)
        else
          add_command(i.to_s + "x", :change_type, true, i)
        end
      end
      if imsi == false || imsi == nil
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      else
        add_command(NEKO::Base, :change_type, true, false)
      end
    end
  end

# Handle for random event menu
  class Window_Encount < Window_CheatCommand_Setting
    def make_command_list
       imsi = @now_setting.checking(menu_name)
      if imsi == 1
        add_command(NEKO::On + NEKO::Now, :change_type, true, 1)
        add_command(NEKO::Off, :change_type, true, 2)
        add_command(NEKO::Base, :change_type, true, false)
      elsif imsi == 2
        add_command(NEKO::On, :change_type, true, 1)
        add_command(NEKO::Off + NEKO::Now, :change_type, true, 2)
        add_command(NEKO::Base, :change_type, true, false)
      else imsi == false || imsi == nil
        add_command(NEKO::On, :change_type, true, 1)
        add_command(NEKO::Off, :change_type, true, 2)
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      end
    end
  end

# Handle for battle skip menu
  class Window_Encount2 < Window_CheatCommand_Setting
    def make_command_list
      imsi = @now_setting.checking(menu_name)
      
      add_command(NEKO::Win + NEKO::Now, :change_type, true, 1) if imsi == 1
      add_command(NEKO::Win, :change_type, true, 1) if imsi != 1
      add_command(NEKO::Lose + NEKO::Now, :change_type, true, 2) if imsi == 2
      add_command(NEKO::Lose, :change_type, true, 2) if imsi != 2
      add_command(NEKO::Escape + NEKO::Now, :change_type, true, 3) if imsi == 3
      add_command(NEKO::Escape, :change_type, true, 3) if imsi != 3
      add_command(NEKO::Not + NEKO::Now, :change_type, true, 4) if imsi == 4
      add_command(NEKO::Not, :change_type, true, 4) if imsi != 4
      add_command(NEKO::Base + NEKO::Now, :change_type, true, false) if !imsi
      add_command(NEKO::Base, :change_type, true, false) if imsi
    end
  end  

# Handle for text speed menu
  class Window_TextView < Window_CheatCommand_Setting
    def make_command_list
       imsi = @now_setting.checking(menu_name)
      if imsi == 1
        add_command(NEKO::On + NEKO::Now, :change_type, true, 1)
        add_command(NEKO::Off, :change_type, true, 2)
        add_command(NEKO::Base, :change_type, true, false)
      elsif imsi == 2
        add_command(NEKO::On, :change_type, true, 1)
        add_command(NEKO::Off + NEKO::Now, :change_type, true, 2)
        add_command(NEKO::Base, :change_type, true, false)
      else imsi == false || imsi == nil
        add_command(NEKO::On, :change_type, true, 1)
        add_command(NEKO::Off, :change_type, true, 2)
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      end
    end
  end

# Handle for enable default debug mode menu
  class Window_Debug_Neko < Window_CheatCommand_Setting
    def make_command_list
       imsi = @now_setting.checking(menu_name)
      if imsi == 1
        add_command(NEKO::On + NEKO::Now, :change_type, true, 1)
        add_command(NEKO::Off, :change_type, true, 2)
        add_command(NEKO::Base, :change_type, true, false)
      elsif imsi == 2
        add_command(NEKO::On, :change_type, true, 1)
        add_command(NEKO::Off + NEKO::Now, :change_type, true, 2)
        add_command(NEKO::Base, :change_type, true, false)
      else imsi == false || imsi == nil
        add_command(NEKO::On, :change_type, true, 1)
        add_command(NEKO::Off, :change_type, true, 2)
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      end
    end
  end

# Handle for volume menu
  class Window_Volume < Window_CheatCommand_Setting
    def make_command_list
      imsi = @now_setting.checking(menu_name)
      for i in 0...11
        i2 = i * 10
        if imsi == i2
          add_command(i2.to_s + "%" + NEKO::Now, :change_type, true, i2)
        else
          add_command(i2.to_s + "%", :change_type, true, i2)
        end
      end
      if imsi == false || imsi == nil
        add_command(NEKO::Base + NEKO::Now, :change_type, true, false)
      else
        add_command(DNEKO::Base, :change_type, true, false)
      end
    end
  end

# Handle config function
  class Scene_Cheat < Scene_MenuBase
  
# Handle battle speed menu
    def neko_battle
      @neko_battle = Window_CheatBattle.new(@now_setting,@setting.current_ext)
      @neko_battle.set_handler(:change_type, method(:change_type))
      @neko_battle.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "battle"
      show_setting_window
    end
	
# Handle movement speed menu
    def neko_speed
      @neko_speed = Window_CheatMove.new(@now_setting,@setting.current_ext)
      @neko_speed.set_handler(:change_type, method(:change_type))
      @neko_speed.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "speed"
      show_setting_window
    end
	
# Handle EXP multiply menu
    def neko_exp
      @neko_exp = Window_Exp.new(@now_setting,@setting.current_ext)
      @neko_exp.set_handler(:change_type, method(:change_type))
      @neko_exp.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "exp"
      show_setting_window
    end

# Handle random event menu
    def neko_encount
      @neko_encount = Window_Encount.new(@now_setting,@setting.current_ext)
      @neko_encount.set_handler(:change_type, method(:change_type))
      @neko_encount.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "encount"
      show_setting_window
    end

# Handle battle skip menu
    def neko_encount2
      @neko_encount2 = Window_Encount2.new(@now_setting,@setting.current_ext)
      @neko_encount2.set_handler(:change_type, method(:change_type))
      @neko_encount2.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "encount2"
      show_setting_window
    end
    
    def neko_text
      @neko_text = Window_TextView.new(@now_setting,@setting.current_ext)
      @neko_text.set_handler(:change_type, method(:change_type))
      @neko_text.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "txt"
      show_setting_window
    end

# Handle debug mode menu
    def neko_debug
      @neko_debug = Window_Debug_Neko.new(@now_setting,@setting.current_ext)
      @neko_debug.set_handler(:change_type, method(:change_type))
      @neko_debug.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "debug"
      show_setting_window
    end

# Handle volume menu
    def neko_sound
      @neko_sound = Window_Volume.new(@now_setting,@setting.current_ext)
      @neko_sound.set_handler(:change_type, method(:change_type))
      @neko_sound.set_handler(:cancel, method(:hide_setting_window))
      @now_menu = "sound"
      show_setting_window
    end
  end

# Create menu window function
  class Scene_Cheat < Scene_MenuBase

# Define which menu are used
    def find_menu
      case @now_menu
        when "speed"; return @neko_speed
        when "sound"; return @neko_sound
        when "exp"; return @neko_exp
        when "encount"; return @neko_encount
        when "encount2"; return @neko_encount2
        when "txt"; return @neko_text
        when "debug"; return @neko_debug
        when "battle"; return @neko_battle
        when "lv"; return @neko_lv
        when "mhp"; return @neko_mhp
        when "mmp"; return @neko_mmp
        when "atk"; return @neko_atk
        when "def"; return @neko_def
        when "mat"; return @neko_mat
        when "mdf"; return @neko_mdf
        when "agi"; return @neko_agi
        when "luk"; return @neko_luk
		when "gold"; return @neko_gold
      end
    end
	
# Handle close menu
    def setting_cancel
      @now_setting = false
      hide_sub_window(@setting)
    end

# Create option for config function, save config
    def change_type
      now_menu = find_menu
      @now_setting.changing(@setting.current_ext,now_menu.current_ext)
      @now_setting.cheat_save
      now_menu.close
      @setting.close
      return_scene
    end
    
# Create second window
    def show_sub_window(window)
      width_remain = Graphics.width - window.width
      window.x = @cheat_window.width
      @viewport.rect.x = 0
      @viewport.rect.width = width_remain
      window.show.activate
    end

# Close second window
    def hide_sub_window(window)
      @viewport.rect.x = @viewport.ox = 0
      @viewport.rect.width = Graphics.width
      window.hide.deactivate
      @cheat_window.refresh
      @cheat_window.activate
    end
    
# Create third window for config function
    def show_setting_window   
      now_menu = find_menu
      width_remain = Graphics.width - now_menu.width
      now_menu.x = @cheat_window.width + @setting.width
      @viewport.rect.x = 0
      @viewport.rect.width = width_remain
      now_menu.show.activate
    end

#Close third window (config)
    def hide_setting_window
      now_menu = find_menu
      @viewport.rect.x = @viewport.ox = 0
      @viewport.rect.width = Graphics.width
      now_menu.hide.deactivate
      now_menu.close
      @setting.refresh
      @setting.activate
    end

# Create third window for parameters edit function
    def show_parameter_window
      now_menu = find_menu
      width_remain = Graphics.width - now_menu.width
      now_menu.x = @cheat_window.width + @edit_parameters.width
      @viewport.rect.x = 0
      @viewport.rect.width = width_remain
      now_menu.show.activate
    end

# Close third window (parameters edit)
    def hide_parameter_window
      now_menu = find_menu
      @viewport.rect.x = @viewport.ox = 0
      @viewport.rect.width = Graphics.width
      now_menu.hide.deactivate
      now_menu.close
      @edit_parameters.refresh
      @edit_parameters.activate
    end
  end

# Handle Full screen, Change window size function
  class Scene_Cheat < Scene_MenuBase
    def screen_full
      Graphics.toggle_fullscreen
      @cheat_window.refresh
      @cheat_window.activate
    end
    def screen_change
      Graphics.toggle_ratio 
      @cheat_window.refresh
      @cheat_window.activate
    end
  end
  
  # Full screen, change window size function
  
  # Fullscreen++ v2.2 for VX and VXace by Zeus81
  # Free for non commercial and commercial use
  # Licence : http://creativecommons.org/licenses/by-sa/3.0/
  # Contact : zeusex81@gmail.com
  # (fr) Manuel d'utilisation : http://pastebin.com/raw.php?i=1TQfMnVJ
  # (en) User Guide           : http://pastebin.com/raw.php?i=EgnWt9ur
   
  $imported ||= {}
  $imported[:Zeus_Fullscreen] = __FILE__

  class << Graphics
    Disable_VX_Fullscreen = false
   
    CreateWindowEx            = Win32API.new('user32'  , 'CreateWindowEx'           , 'ippiiiiiiiii', 'i')
    GetClientRect             = Win32API.new('user32'  , 'GetClientRect'            , 'ip'          , 'i')
    GetDC                     = Win32API.new('user32'  , 'GetDC'                    , 'i'           , 'i')
    GetSystemMetrics          = Win32API.new('user32'  , 'GetSystemMetrics'         , 'i'           , 'i')
    GetWindowRect             = Win32API.new('user32'  , 'GetWindowRect'            , 'ip'          , 'i')
    FillRect                  = Win32API.new('user32'  , 'FillRect'                 , 'ipi'         , 'i')
    FindWindow                = Win32API.new('user32'  , 'FindWindow'               , 'pp'          , 'i')
    ReleaseDC                 = Win32API.new('user32'  , 'ReleaseDC'                , 'ii'          , 'i')
    SendInput                 = Win32API.new('user32'  , 'SendInput'                , 'ipi'         , 'i')
    SetWindowLong             = Win32API.new('user32'  , 'SetWindowLong'            , 'iii'         , 'i')
    SetWindowPos              = Win32API.new('user32'  , 'SetWindowPos'             , 'iiiiiii'     , 'i')
    ShowWindow                = Win32API.new('user32'  , 'ShowWindow'               , 'ii'          , 'i')
    SystemParametersInfo      = Win32API.new('user32'  , 'SystemParametersInfo'     , 'iipi'        , 'i')
    UpdateWindow              = Win32API.new('user32'  , 'UpdateWindow'             , 'i'           , 'i')
    GetPrivateProfileString   = Win32API.new('kernel32', 'GetPrivateProfileString'  , 'ppppip'      , 'i')
    WritePrivateProfileString = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp'        , 'i')
    CreateSolidBrush          = Win32API.new('gdi32'   , 'CreateSolidBrush'         , 'i'           , 'i')
    DeleteObject              = Win32API.new('gdi32'   , 'DeleteObject'             , 'i'           , 'i')
   
    unless method_defined?(:zeus_fullscreen_update)
      HWND     = FindWindow.call('RGSS Player', 0)
      BackHWND = CreateWindowEx.call(0x08000008, 'Static', '', 0x80000000, 0, 0, 0, 0, 0, 0, 0, 0)
      alias zeus_fullscreen_resize_screen resize_screen if !$setting
      alias zeus_fullscreen_update        update if !$setting
    end
  private
    def initialize_fullscreen_rects
      @borders_size    ||= borders_size
      @fullscreen_rect ||= screen_rect
      @workarea_rect   ||= workarea_rect
    end
    def borders_size
      GetWindowRect.call(HWND, wrect = [0, 0, 0, 0].pack('l4'))
      GetClientRect.call(HWND, crect = [0, 0, 0, 0].pack('l4'))
      wrect, crect = wrect.unpack('l4'), crect.unpack('l4')
      Rect.new(0, 0, wrect[2]-wrect[0]-crect[2], wrect[3]-wrect[1]-crect[3])
    end
    def screen_rect
      Rect.new(0, 0, GetSystemMetrics.call(0), GetSystemMetrics.call(1))
    end
    def workarea_rect
      SystemParametersInfo.call(0x30, 0, rect = [0, 0, 0, 0].pack('l4'), 0)
      rect = rect.unpack('l4')
      Rect.new(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
    end
    def hide_borders() SetWindowLong.call(HWND, -16, 0x14000000) end
    def show_borders() SetWindowLong.call(HWND, -16, 0x14CA0000) end
    def hide_back()    ShowWindow.call(BackHWND, 0)              end
    def show_back
      ShowWindow.call(BackHWND, 3)
      UpdateWindow.call(BackHWND)
      dc    = GetDC.call(BackHWND)
      rect  = [0, 0, @fullscreen_rect.width, @fullscreen_rect.height].pack('l4')
      brush = CreateSolidBrush.call(0)
      FillRect.call(dc, rect, brush)
      ReleaseDC.call(BackHWND, dc)
      DeleteObject.call(brush)
    end
    def resize_window(w, h)
      if @fullscreen
        x, y, z = (@fullscreen_rect.width-w)/2, (@fullscreen_rect.height-h)/2, -1
      else
        w += @borders_size.width
        h += @borders_size.height
        x = @workarea_rect.x + (@workarea_rect.width  - w) / 2
        y = @workarea_rect.y + (@workarea_rect.height - h) / 2
        z = -2
      end
      SetWindowPos.call(HWND, z, x, y, w, h, 0)
    end
    def release_alt
      inputs = [1,18,2, 1,164,2, 1,165,2].pack('LSx2Lx16'*3)
      SendInput.call(3, inputs, 28)
    end
  public
    def load_fullscreen_settings
      buffer = [].pack('x256')
      section = 'Fullscreen++'
      filename = './Game.ini'
      get_option = Proc.new do |key, default_value|
        l = GetPrivateProfileString.call(section, key, default_value, buffer, buffer.size, filename)
        buffer[0, l]
      end
      @fullscreen       = get_option.call('Fullscreen'     , '0') == '1'
      @fullscreen_ratio = get_option.call('FullscreenRatio', '0').to_i
      @windowed_ratio   = get_option.call('WindowedRatio'  , '1').to_i
      toggle_vx_fullscreen if Disable_VX_Fullscreen and vx_fullscreen?
      fullscreen? ? fullscreen_mode : windowed_mode
    end
    def save_fullscreen_settings
      section = 'Fullscreen++'
      filename = './Game.ini'
      set_option = Proc.new do |key, value|
        WritePrivateProfileString.call(section, key, value.to_s, filename)
      end
      set_option.call('Fullscreen'     , @fullscreen ? '1' : '0')
      set_option.call('FullscreenRatio', @fullscreen_ratio)
      set_option.call('WindowedRatio'  , @windowed_ratio)
    end
    def fullscreen?
      @fullscreen or vx_fullscreen?
    end
    def vx_fullscreen?
      rect = screen_rect
      rect.width == 640 and rect.height == 480
    end
    def toggle_fullscreen
      fullscreen? ? windowed_mode : fullscreen_mode
    end
    def toggle_vx_fullscreen
      windowed_mode if @fullscreen and !vx_fullscreen?
      inputs = [1,18,0, 1,13,0, 1,13,2, 1,18,2].pack('LSx2Lx16'*4)
      SendInput.call(4, inputs, 28)
      zeus_fullscreen_update
      self.ratio += 0 # refresh window size
    end
    def vx_fullscreen_mode
      return if vx_fullscreen?
      toggle_vx_fullscreen
    end
    def fullscreen_mode
      return if vx_fullscreen?
      initialize_fullscreen_rects
      show_back
      hide_borders
      @fullscreen = true
      self.ratio += 0 # refresh window size
    end
    def windowed_mode
      toggle_vx_fullscreen if vx_fullscreen?
      initialize_fullscreen_rects
      hide_back
      show_borders
      @fullscreen = false
      self.ratio += 0 # refresh window size
    end
    def toggle_ratio
      return if vx_fullscreen?
      self.ratio += 1
    end
    def ratio
      return 1 if vx_fullscreen?
      @fullscreen ? @fullscreen_ratio : @windowed_ratio
    end
    def ratio=(r)
      return if vx_fullscreen?
      initialize_fullscreen_rects
      r = 0 if r < 0
      if @fullscreen
        @fullscreen_ratio = r
        w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
      else
        @windowed_ratio = r
        w_max = @workarea_rect.width  - @borders_size.width
        h_max = @workarea_rect.height - @borders_size.height
      end
      if r == 0
        w, h = w_max, w_max * height / width
        h, w = h_max, h_max * width / height if h > h_max
      else
        w, h = width * r, height * r
        return self.ratio = 0 if w > w_max or h > h_max
      end
      resize_window(w, h)
      save_fullscreen_settings
    end
    def ratio_r(r)
          return if vx_fullscreen?
      initialize_fullscreen_rects
      r = 0 if r < 0
      if @fullscreen
        @fullscreen_ratio = r
        w_max, h_max = @fullscreen_rect.width, @fullscreen_rect.height
      else
        @windowed_ratio = r
        w_max = @workarea_rect.width  - @borders_size.width
        h_max = @workarea_rect.height - @borders_size.height
      end
      if r == 0
        w, h = w_max, w_max * height / width
        h, w = h_max, h_max * width / height if h > h_max
      else
        w, h = width * r, height * r
        return self.ratio = 0 if w > w_max or h > h_max
      end
      resize_window(w, h)
      save_fullscreen_settings
    end
    def update
      release_alt if Disable_VX_Fullscreen and Input.trigger?(Input::ALT)
      zeus_fullscreen_update
    end
    def resize_screen(width, height)
      zeus_fullscreen_resize_screen(width, height)
      self.ratio += 0 # refresh window size
    end
  end

# Function handler
  class Game_Player < Game_Character
  
# Count total item (No longer used, will be deleted soon)
    def check_item
      arr = load_data("Data/Items.rvdata2")
      @neko_item_count = arr.size.to_i
    end
    def neko_item_count
      @neko_item_count
    end

# Battle skip handler
    alias neko_update_encounter update_encounter if !$setting
    def update_encounter
      if opening("encount") == 1
        return
      else
        neko_update_encounter
      end
    end

# No clip handler
    alias neko_debug_through? debug_through? if !$setting
    def debug_through?
      if opening("debug") == 1 && Input.press?(:CTRL)
        return true 
      end
      if $TEST && Input.press?(:CTRL)
        return true 
      end
      return false
    end
  end

# Battle skip handler
  class Game_Interpreter
    alias neko_command_301 command_301 if !$setting
    alias neko_command_601 command_601 if !$setting
    alias neko_command_602 command_602 if !$setting
    alias neko_command_603 command_603 if !$setting
    def command_301
      return if $game_player.opening("encount2")
      neko_command_301
    end
    def command_601
      return if $game_player.opening("encount2") == 1
      if $game_player.opening("encount2")
        command_skip
      else
        neko_command_601
      end
    end
    def command_602
      return if $game_player.opening("encount2") == 3
      if $game_player.opening("encount2")
        command_skip
      else
        neko_command_602
      end
    end
    def command_603
      return if $game_player.opening("encount2") == 2
      if $game_player.opening("encount2")
        command_skip
      else
        neko_command_603
      end
    end
  end

# Movement speed handler
  class Game_CharacterBase
    alias neko_real_move_speed real_move_speed if !$setting
    def real_move_speed
      if dash?
        return neko_dash
      else
        return neko_move
      end
    end
    
    def neko_dash
      if $game_player.opening("dash")
        return $game_player.opening("dash")
      else
        return neko_move + 1
      end
    end
    
    def neko_move
      if $game_player.opening("move")
        return $game_player.opening("move")
      else
        return @move_speed
      end
    end
  end

# Text speed handler
  class Window_Message < Window_Base
    alias neko_clear_flags clear_flags if !$setting
    def clear_flags
      neko_clear_flags
      if $game_player.opening("txt") == 1 && $game_message.choices.size == 0
        @show_fast = true 
      end
    end
  end # Window_Message


  class Game_Troop < Game_Unit
    alias neko_exp_total exp_total if !$setting
    def exp_total
      if $game_player.opening("exp") == false
        neko_exp_total
      else
        neko_exp_total * $game_player.opening("exp")
      end
    end
  end

# Volume config handler
  class RPG::BGM < RPG::AudioFile
    alias neko_play play if !$setting
    def play(pos = 0)
      if $game_player.opening('bgm')
        @volume = $game_player.opening('bgm') 
      end
      neko_play(pos)
    end
  end
  class RPG::BGS < RPG::AudioFile
    alias neko_play play if !$setting
    def play(pos = 0)
      if $game_player.opening('bgs')
        @volume = $game_player.opening('bgs') 
      end
      neko_play(pos)
    end
  end
  class RPG::ME < RPG::AudioFile
    alias neko_play play if !$setting
    def play
      if $game_player.opening('me')
        @volume = $game_player.opening('me') 
      end
      neko_play
    end
  end
  class RPG::SE < RPG::AudioFile
    alias neko_play play if !$setting
    def play
      if $game_player.opening('se')
        @volume = $game_player.opening('se') 
      end
      neko_play
    end
  end

# Battle speed handler
  class << Graphics
    def neko_get_speed
      if SceneManager.scene_is?(Scene_Battle)
        if $game_player.opening("battle")
          return $game_player.opening("battle") 
        end
      else
        if $game_player.opening("nobattle")
          return $game_player.opening("nobattle") 
        end
      end
      return 1
    end
    def spd_frame_count
      @spd_frame_count = Graphics.frame_count if @spd_frame_count == nil
      return @spd_frame_count
    end
    def spd_frame_count=(count)
      @spd_frame_count = count
    end
    alias :neko_update_spd :update if !$setting
    def update
      if Graphics.frame_count % neko_get_speed.to_i > 0
        Graphics.frame_count += 1
      else
        Graphics.spd_frame_count += 1
        neko_update_spd
      end
    end
    alias :neko_wait_spd :wait if !$setting
    def wait(duration)
      duration /= neko_get_speed
      neko_wait_spd(duration)
    end
    alias :neko_fadein_spd :fadein if !$setting
    def fadein(duration)
      duration /= neko_get_speed
      neko_fadein_spd(duration)
    end
    alias :neko_fadeout_spd :fadeout if !$setting
    def fadeout(duration)
      duration /= neko_get_speed
      neko_fadeout_spd(duration)
    end
    alias :neko_transition_spd :transition if !$setting
    def transition(duration = 10, filename = "", vague = 40)
      duration /= neko_get_speed
      neko_transition_spd(duration, filename, vague)
    end
  end
